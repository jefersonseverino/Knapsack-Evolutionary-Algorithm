# -*- coding: utf-8 -*-
"""Knapsack.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10c7osRJp7b9Nf88g2FLBhoD25CFp1xYr

Knapsack Problem Evolutionary
"""

import random

class Item:

  def __init__(self, value, weight):
    self.value = value
    self.weight = weight

# Creation of the products

items_list = []
population_size = 200
genoma_size = 100
number_of_itens = 100

for i in range(0, genoma_size):
  value = random.randint(1, 1000)
  weight = random.randint(1, 50)

  items_list.append(Item(value, weight))

# genome is a list of integers

def fitness(genome):
  value = 0
  weight = 0

  for idx, gene in enumerate(genome):
    value += gene * items_list[idx].value
    weight += gene * items_list[idx].weight

  # penalty = abs(weight - 100)
  # fitness = value - penalty # (value - (100 * penalty)) if weight > 100 else value

  excess_weight = max(0, weight - 100)
  penalty = excess_weight ** 2
  fitness = value - penalty

  print(value, weight, fitness)

  return fitness

def is_individual_valid(individual):
  total_weight = 0
  for idx in range(0, len(individual)):
    total_weight += (items_list[idx].weight) * (individual[idx])

  return total_weight <= 100

def tournament(population):
  parents_candidates = random.sample(population, 10)
  parents_candidates = sorted(parents_candidates, reverse=True, key=fitness)
  return parents_candidates[:2]

def crossover(parents_list):
  children = []
  for parents in parents_list:
    idx = random.randint(0, population_size - 1)
    children.append(parents[0][:idx] + parents[1][idx:])
    children.append(parents[1][:idx] + parents[0][idx:])
  return children


def mutation(children):
  # Check mutation in the same child
  mutated_children = int(0.1 * len(children)) # Mutation rate changed to 0.05 (Initial)
  for i in range(0, mutated_children):
    selected_child = random.randint(0, len(children) - 1)
    mutated_genes = random.sample(range(0, genoma_size), 5)
    for idx in mutated_genes:
      children[selected_child][idx] = 1 - children[selected_child][idx]
  return children

def remove_invalids(children):
  valid_children = []
  for child in children:
    if is_individual_valid(child):
      valid_children.append(child)

  return valid_children

def roulette(population):
  # Roulette to reduce the population
  # Prob / total
  fitness_list = [fitness(individual) for individual in population]
  total_fitness = sum(fitness_list)
  probabilities = [(ind_fitness / total_fitness) for ind_fitness in fitness_list]
  #print(probabilities)
  #normalized_probabilities = [2**w for w in probabilities]
  #print(normalized_probabilities)
  selected_individuals = random.choices(population, probabilities, k=population_size)

  return selected_individuals

def knapsack_dp(items_list, capacity):
    n = len(items_list)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            current_item = items_list[i - 1]
            if current_item.weight > w:
                dp[i][w] = dp[i - 1][w]
            else:
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - current_item.weight] + current_item.value)
    selected_items = []
    total_value = dp[n][capacity]
    total_weight = capacity
    for i in range(n, 0, -1):
        if dp[i][total_weight] != dp[i - 1][total_weight]:
            selected_items.append(i - 1)
            total_weight -= items_list[i - 1].weight
    selected_items = selected_items[::-1]

    return selected_items, total_value, capacity-total_weight

population = []

# Initial population
# Change later for better approach

while len(population) < population_size:
  individual = [0] * genoma_size
  total_weight = 0
  while total_weight <= 100:
    random_item = random.randint(0, number_of_itens-1)
    #if total_weight + items_list[random_item].weight > 100:
    #  break
    total_weight += items_list[random_item].weight
    individual[random_item] = 1
  population.append(individual)

# Create all generations

generation_number = 0
best_fitness = 0
best_fit_count = 0

# Stop condition will change to fitness function not chaging through 10 generations
while generation_number < 10:

  # Generate fitness for the current population
  parents = []

  # Parents selection
  for recombination in range(0, 10): # Was 50 now is 75
    parents.append(tournament(population))

  # Do Crossover
  children = crossover(parents)

  # Mutate
  children = mutation(children)

  # Kill

  # Add new children to the population
  population += children

  population = roulette(population)

  # Check stop condition
  fitness_list = [fitness(individual) for individual in population]
  current_best = sum(fitness_list)

  if current_best == best_fitness:
    best_fit_count += 1
  elif current_best > best_fitness:
    best_fit_count = 0
    best_fitness = current_best

  if best_fit_count > 100:
    print('Convergiu')
    break

  generation_number += 1

fitness_list = [fitness(individual) for individual in population]
current_best = sum(fitness_list)

idx_solution = fitness_list.index(max(fitness_list))
best_individual = population[idx_solution]
choosen_items_idx = [i for i, valor in enumerate(best_individual) if valor == 1]
total_value = sum(items_list[i].value for i in choosen_items_idx)
total_weight = sum(items_list[i].weight for i in choosen_items_idx)

print('Solução - Algoritmo Genético')
print('Número de iterações:', generation_number)
print('Itens escolhidos:', choosen_items_idx)
print('Valor total:', total_value)
print('Peso total:', total_weight)
print('-------------------------')
dp_choosen_items_idx, dp_total_value, dp_total_weight = knapsack_dp(items_list, 100)
print('Solução - DP')
print('Itens escolhidos:', dp_choosen_items_idx)
print('Valor total:', dp_total_value)
print('Peso total:', dp_total_weight)